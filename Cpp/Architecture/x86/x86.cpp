#include "..\..\..\H\Architecture\x86\x86.h"
#include "../../../H/Back/Token.h"


void x86::ARC_Factory()
{
	OpC* x86_ADD_ = new OpC(0, "+", "add ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_ADD_);
	OpC* x86_ADDF_ = new OpC(0, "+", "addss ", { 12, 12, 12, 12});
	OpCodes.push_back(x86_ADDF_);
	OpC* x86_OR_ = new OpC(0, "|", "or ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_OR_);
	OpC* x86_AND_ = new OpC(0, "&", "and ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_AND_);
	OpC* x86_XOR_ = new OpC(0, "^", "xor ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_XOR_);
	OpC* x86_CMP_ = new OpC(0, "cmp", "cmp ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_CMP_);
	OpC* x86_CMPF_ = new OpC(0, "cmp", "cmpss ", { 12, 12, 12, 12 });
	OpCodes.push_back(x86_CMPF_);
	OpC* x86_Question_ = new OpC(0, "?", "cmp ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_Question_);
	OpC* x86_POP_ = new OpC(0, "pop", "pop ", { 2, 8, 2, 8 });
	OpCodes.push_back(x86_POP_);
	OpC* x86_PUSH_ = new OpC(0, "push", "push ", { 2, 8, 2, 8 });
	OpCodes.push_back(x86_PUSH_);
	OpC* x86_XCHG_ = new OpC(0, "xchg", "xchg ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_XCHG_);
	OpC* x86_LOAD_ = new OpC(0, "ldr", "mov ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_LOAD_);
	OpC* x86_STORE_ = new OpC(0, "str", "mov ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_STORE_);
	OpC* x86_SET_TO_ = new OpC(0, "=", "mov ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_SET_TO_);
	OpC* x86_MOVF_ = new OpC(0, "=", "movss ", { 12, 12, 12, 12 });
	OpCodes.push_back(x86_MOVF_);
	OpC* x86_ConvertSmallToLarge_ = new OpC(0, "scale", "movsx ", { 8, 8, 1, 2 });
	OpCodes.push_back(x86_ConvertSmallToLarge_);
	OpC* x86_ConvertLargeToEnourmess_ = new OpC(0, "scale2", "cvtsi2sd ", { 12, 12, 4, 4 });
	OpCodes.push_back(x86_ConvertLargeToEnourmess_);
	OpC* x86_LEA_ = new OpC(0, ":", "lea ", { 2, 8, 2, 8 });
	OpCodes.push_back(x86_LEA_);
	OpC* x86_SHL_ = new OpC(0, "<<", "shl ", { 1, 4, 1, 1 });
	OpCodes.push_back(x86_SHL_);
	OpC* x86_SHR_ = new OpC(0, ">>", "shr ", { 1, 4, 1, 1 });
	OpCodes.push_back(x86_SHR_);
	OpC* x86_NEG_ = new OpC(0, "neg", "neg ", { 1, 8, 0, 0 });
	OpCodes.push_back(x86_NEG_);
	OpC* x86_NOT_ = new OpC(0, "!", "not ", { 1, 8, 0, 0 });
	OpCodes.push_back(x86_NOT_);
	OpC* x86_CALL_ = new OpC(0, "call", "call ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_CALL_);
	OpC* x86_SUB_ = new OpC(0, "-", "sub ", { 1, 8, 1, 8 });
	OpCodes.push_back(x86_SUB_);
	OpC* x86_SUBF_ = new OpC(0, "-", "subss ", { 12, 12, 12, 12 });
	OpCodes.push_back(x86_SUBF_);
	OpC* x86_IMUL_ = new OpC(0, "*", "imul ", { 2, 8, 2, 8 });
	OpCodes.push_back(x86_IMUL_);
	OpC* x86_MULF_ = new OpC(0, "*", "mulss ", { 12, 12, 12, 12 });
	OpCodes.push_back(x86_MULF_);
	OpC* x86_IDIV_ = new OpC(0, "/", "idiv ", { 2, 8, 2, 8 });
	OpCodes.push_back(x86_IDIV_);
	OpC* x86_DIVF_ = new OpC(0, "/", "divss ", { 12, 12, 12, 12 });
	OpCodes.push_back(x86_DIVF_);
	OpC* x86_JNE_ = new OpC(0, "==", "jne ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JNE_);
	OpC* x86_JE_ = new OpC(0, "!=", "je ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JE_);
	OpC* x86_JNLE_ = new OpC(0, "<=", "jnle ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JNLE_);
	OpC* x86_JNGE_ = new OpC(0, ">=", "jnge ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JNGE_);
	OpC* x86_JLE_ = new OpC(0, "!<", "jle ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JLE_);
	OpC* x86_JGE_ = new OpC(0, "!>", "jge ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JGE_);
	OpC* x86_JNL_ = new OpC(0, "<", "jnl ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JNL_);
	OpC* x86_JNG_ = new OpC(0, ">", "jng ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JNG_);
	OpC* x86_JMP_ = new OpC(0, "jmp", "jmp ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_JMP_);
	OpC* x86_RET_ = new OpC(0, "return", "ret ", { 0, 0, 0, 0 });
	OpCodes.push_back(x86_RET_);
	OpC* x86_DWORD_ = new OpC(0, "4", "dword ", { 4, 4, 0, 0 });
	OpCodes.push_back(x86_DWORD_);
	OpC* x86_QWORD_ = new OpC(0, "8", "qword ", { 8, 8, 0, 0 });
	OpCodes.push_back(x86_QWORD_);
	OpC* x86_WORD_ = new OpC(0, "2", "word ", { 2, 2, 0, 0 });
	OpCodes.push_back(x86_WORD_);
	OpC* x86_BYTE_ = new OpC(0, "1", "byte ", { 1, 1, 0, 0 });
	OpCodes.push_back(x86_BYTE_);
	OpC* x86_NULL_ = new OpC(0, "0", "", { 0, 0, 0, 0 });
	OpCodes.push_back(x86_NULL_);
	OpC* x86_LABEL_ = new OpC(0, "label", ": ", { 0, 0, 0, 0 });
	OpCodes.push_back(x86_LABEL_);
	OpC* x86_COMMENT_ = new OpC(0, "comment", "; ", { 0, 0, 0, 0 });
	OpCodes.push_back(x86_COMMENT_);
	OpC* x86_EXPORT_ = new OpC(0, "export", "global ", { 0, 8, 0, 0 });
	OpCodes.push_back(x86_EXPORT_);


	//8Bit
	AL = new Token("AL ", 1);
	AL->Flags |= Task_For_Returning;
	AL->Flags |= Task_For_General_Purpose;
	Registers8.push_back(AL);
	AH = new Token("AH ", 1);
	AH->Flags |= Task_For_Returning;
	AH->Flags |= Task_For_General_Purpose;
	Registers8.push_back(AH);
	BL = new Token("BL ", 1);
	BL->Flags |= Task_For_General_Purpose;
	Registers8.push_back(BL);
	BH = new Token("BH ", 1);
	BH->Flags |= Task_For_General_Purpose;
	Registers8.push_back(BH);
	CL = new Token("CL ", 1);
	CL->Flags |= Task_For_General_Purpose;
	Registers8.push_back(CL);
	CH = new Token("CH ", 1);
	CH->Flags |= Task_For_General_Purpose;
	Registers8.push_back(CH);
	DL = new Token("DL ", 1);
	DL->Flags |= Task_For_Remainder;
	DL->Flags |= Task_For_General_Purpose;
	Registers8.push_back(DL);
	DH = new Token("DH ", 1);
	DH->Flags |= Task_For_Remainder;
	DH->Flags |= Task_For_General_Purpose;
	Registers8.push_back(DH);

	//16Bit
	AX = new Token("AX ", 2, AL, AH);
	AX->Flags |= Task_For_Returning;
	AX->Flags |= Task_For_General_Purpose;
	Registers16.push_back(AX);
	BX = new Token("BX ", 2, BL, BH);
	BX->Flags |= Task_For_General_Purpose;
	Registers16.push_back(BX);
	CX = new Token("CX ", 2, CL, CH);
	CX->Flags |= Task_For_General_Purpose;
	Registers16.push_back(CX);
	DX = new Token("DX ", 2, DL, DH);
	DX->Flags |= Task_For_Remainder;
	DX->Flags |= Task_For_General_Purpose;
	Registers16.push_back(DX);
	DI = new Token("DI ", 2);
	DI->Flags |= Task_For_Offsetting;
	DI->Flags |= Task_For_General_Purpose;
	Registers16.push_back(DI);
	SI = new Token("SI ", 2);
	SI->Flags |= Task_For_Offsetting;
	SI->Flags |= Task_For_General_Purpose;
	Registers16.push_back(SI);
	SP = new Token("SP ", 2);
	SP->Flags |= Task_For_Type_Address;
	Registers16.push_back(SP);
	BP = new Token("BP ", 2);
	BP->Flags |= Task_For_Type_Address_Basing;
	Registers16.push_back(BP);

	//32 bit
	EAX = new Token("EAX ", 4, AX);
	EAX->Flags |= Task_For_Returning;
	EAX->Flags |= Task_For_General_Purpose;
	Registers32.push_back(EAX);
	EBX = new Token("EBX ", 4, BX);
	EBX->Flags |= Task_For_General_Purpose;
	Registers32.push_back(EBX);
	ECX = new Token("ECX ", 4, CX);
	ECX->Flags |= Task_For_General_Purpose;
	Registers32.push_back(ECX);
	EDX = new Token("EDX ", 4, DX);
	EDX->Flags |= Task_For_Remainder;
	EDX->Flags |= Task_For_General_Purpose;
	Registers32.push_back(EDX);
	EDI = new Token("EDI ", 4, DI);
	EDI->Flags |= Task_For_Offsetting;
	EDI->Flags |= Task_For_General_Purpose;
	Registers32.push_back(EDI);
	ESI = new Token("ESI ", 4, SI);
	ESI->Flags |= Task_For_Offsetting;
	ESI->Flags |= Task_For_General_Purpose;
	Registers32.push_back(ESI);
	ESP = new Token("ESP ", 4, SP);
	ESP->Flags |= Task_For_Type_Address;
	Registers32.push_back(ESP);
	EBP = new Token("EBP ", 4, BP);
	EBP->Flags |= Task_For_Type_Address_Basing;
	Registers32.push_back(EBP);

	//64 bit
	RAX = new Token("RAX ", 8, EAX);
	RAX->Flags |= Task_For_Returning;
	RAX->Flags |= Task_For_General_Purpose;
	Registers64.push_back(RAX);
	RBX = new Token("RBX ", 8, EBX);
	RBX->Flags |= Task_For_General_Purpose;
	Registers64.push_back(RBX);
	RCX = new Token("RCX ", 8, ECX);
	RCX->Flags |= Task_For_General_Purpose;
	Registers64.push_back(RCX);
	RDX = new Token("RDX ", 8, EDX);
	RDX->Flags |= Task_For_Remainder;
	RDX->Flags |= Task_For_General_Purpose;
	Registers64.push_back(RDX);
	RDI = new Token("RDI ", 8, EDI);
	RDI->Flags |= Task_For_Offsetting;
	RDI->Flags |= Task_For_General_Purpose;
	Registers64.push_back(RDI);
	RSI = new Token("RSI ", 8, ESI);
	RSI->Flags |= Task_For_Offsetting;
	RSI->Flags |= Task_For_General_Purpose;
	Registers64.push_back(RSI);
	RSP = new Token("RSP ", 8, ESP);
	RSP->Flags |= Task_For_Type_Address;
	Registers64.push_back(RSP);
	RBP = new Token("RBP ", 8, EBP);
	RBP->Flags |= Task_For_Type_Address_Basing;
	Registers64.push_back(RBP);

	//64 bit float
	MMX0 = new Token("XMM0 ", 12);
	MMX0->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX0);
	MMX1 = new Token("XMM1 ", 12);
	MMX1->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX1);
	MMX2 = new Token("XMM2 ", 12);
	MMX2->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX2);
	MMX3 = new Token("XMM3 ", 12);
	MMX3->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX3);
	MMX4 = new Token("XMM4 ", 12);
	MMX4->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX4);
	MMX5 = new Token("XMM5 ", 12);
	MMX5->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX5);
	MMX6 = new Token("XMM6 ", 12);
	MMX6->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX6);
	MMX7 = new Token("XMM7 ", 12);
	MMX7->Flags |= Task_For_Floating_Math;
	Registers128.push_back(MMX7);
}
